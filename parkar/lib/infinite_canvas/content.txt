file: -- models\canvas_object.dart
import 'package:flutter/material.dart';
import 'dart:math' as math;

import 'package:uuid/uuid.dart';

/// Enum que define los modos de edición y tipos de objetos.
enum InfiniteCanvasObjectType { gridObject, text, line, freeForm }

/// Clase base para los objetos del lienzo.
abstract class InfiniteCanvasObject {
  final InfiniteCanvasObjectType objectType;
  final key = GlobalKey();
  final String id;
  Offset position;
  Color color;
  double rotation;
  double scale;
  Size size;
  bool selected = false;

  InfiniteCanvasObject({
    Offset? position,
    Color? color,
    double? rotation,
    double? scale,
    Size? size,
    String? id,
    required this.objectType,
  })  : id = id ?? const Uuid().v4(), // Inicializa id en el cuerpo
        position = position ?? Offset.zero, // Valor por defecto sin const
        color = color ?? const Color.fromARGB(255, 154, 1, 250),
        rotation = rotation ?? 0.0,
        scale = scale ?? 1.0,
        size = size ?? const Size(1, 1);

  // InfiniteCanvasObject copyWith({
  //   String? id,
  //   Offset? position,
  //   Color? color,
  //   double? rotation,
  //   double? scale,
  //   Size? size,
  // });

  void draw(Canvas canvas, Paint paint, Offset canvasOffset, double gridSize,
      double scale);

  bool contains(
      Offset point, Offset canvasOffset, double gridSize, double scale);

  Offset rotatePoint(Offset point, double angle) {
    final radians = angle * (math.pi / 180);
    final cosTheta = math.cos(radians);
    final sinTheta = math.sin(radians);
    return Offset(
      point.dx * cosTheta - point.dy * sinTheta,
      point.dx * sinTheta + point.dy * cosTheta,
    );
  }

  void rotate(double angle) {
    rotation += angle;
  }

  void scalate(double scale) {
    this.scale *= scale;
  }

  void translate(Offset offset) {
    position += offset;
  }

  void resize(Size size) {
    this.size = size;
  }

  void select() {
    selected = !selected;
  }
}


file: -- models\facility_object.dart
import 'package:flutter/material.dart';
import 'package:parkar/infinite_canvas/models/canvas_object.dart';
import 'dart:math' as math;

import 'grid_object.dart';
import 'helpers/selected_inidcator.dart';

enum FacilityObjectType { office, elevator, stairs, bathroom }

FacilityObjectType intToFacilityObjectType(int value) {
  if (value >= 0 && value < FacilityObjectType.values.length) {
    return FacilityObjectType.values[value];
  } else {
    return FacilityObjectType.office;
  }
}

class FacilityObject extends GridObject {
  final FacilityObjectType type;
  final String label;

  // Tamaños predefinidos para cada tipo de instalación
  static const Map<FacilityObjectType, Size> facilitySizes = {
    FacilityObjectType.office: Size(8, 8), // 8x8 metros
    FacilityObjectType.elevator: Size(4, 4), // 4x4 metros
    FacilityObjectType.stairs: Size(6, 6), // 6x6 metros
    FacilityObjectType.bathroom: Size(6, 4), // 6x4 metros
  };

  // Colores predefinidos para cada tipo de instalación
  static const Map<FacilityObjectType, Color> facilityColors = {
    FacilityObjectType.office: Colors.greenAccent, // Azul suave
    FacilityObjectType.elevator: Color(0xFFDAA520), // Dorado
    FacilityObjectType.stairs: Color(0xFF32CD32), // Verde lima
    FacilityObjectType.bathroom: Color(0xFFFF6347), // Coral
  };

  // Etiquetas predefinidas para cada tipo de instalación
  static const Map<FacilityObjectType, String> facilityLabels = {
    FacilityObjectType.office: 'Oficina',
    FacilityObjectType.elevator: 'Ascensor',
    FacilityObjectType.stairs: 'Gradas',
    FacilityObjectType.bathroom: 'Baño',
  };

  FacilityObject({
    super.position = const Offset(0, 0),
    super.id,
    required this.type,
    String? customLabel, // Etiqueta personalizada (opcional)
  })  : label = customLabel ??
            facilityLabels[
                type]!, // Usar etiqueta predefinida si no se proporciona una personalizada
        super(
          size: Size(facilitySizes[type]!.width, facilitySizes[type]!.height),
          color: facilityColors[type]!,
        );

  @override
  void drawContent(
    Canvas canvas,
    Paint paint,
    Rect rect,
    Offset canvasOffset,
    double gridSize,
    double scale,
  ) {
    // Dibujar el texto
    final textPainter = TextPainter(
      text: TextSpan(
        text: label,
        style: TextStyle(
          color: Colors.white, // Texto en blanco
          fontSize: 10, // Tamaño de fuente más pequeño
          fontWeight: FontWeight.normal,
          shadows: [
            Shadow(
              color: Colors.black.withAlpha(128), // Sombra del texto
              blurRadius: 2,
              offset: const Offset(1, 1),
            ),
          ],
        ),
      ),
      textDirection: TextDirection.ltr,
    );
    textPainter.layout();
    textPainter.paint(
      canvas,
      Offset(
        (size.width * gridSize - textPainter.width) / 2,
        (size.height * gridSize - textPainter.height) / 2,
      ),
    );
  }

}


file: -- models\free_form_object.dart
import 'package:flutter/material.dart';
import 'canvas_object.dart';
import 'dart:math' as math;

/// Objeto que representa una forma libre.
class FreeFormObject extends InfiniteCanvasObject {
  List<Offset> points;

  FreeFormObject({
    required super.position,
    required super.color,
    required this.points,
    super.id,
    super.objectType = InfiniteCanvasObjectType.freeForm,
  });

  @override
  void draw(Canvas canvas, Paint paint, Offset canvasOffset, double scale,
      double baseUnitSize) {
    canvas.save();
    canvas.translate(canvasOffset.dx, canvasOffset.dy);
    canvas.scale(scale);
    canvas.translate(position.dx, position.dy);
    canvas.rotate(rotation * (math.pi / 180));

    final path = Path();
    if (points.isNotEmpty) {
      path.moveTo(points[0].dx, points[0].dy);
      for (var point in points) {
        path.lineTo(point.dx, point.dy);
      }
      path.close();
    }

    paint.style = PaintingStyle.stroke;
    paint.strokeWidth = 2;
    canvas.drawPath(path, paint);

    canvas.restore();
  }

  @override
  bool contains(
      Offset point, Offset canvasOffset, double scale, double baseUnitSize) {
    final transformedPoint = (point - canvasOffset) / scale;
    final rotatedPoint = rotatePoint(transformedPoint - position, -rotation);

    final path = Path();
    if (points.isNotEmpty) {
      path.moveTo(points[0].dx, points[0].dy);
      for (var point in points) {
        path.lineTo(point.dx, point.dy);
      }
      path.close();
    }

    return path.contains(rotatedPoint);
  }
}


file: -- models\grid_object.dart
import 'package:flutter/material.dart';
import 'canvas_object.dart';
import 'dart:math' as math;

import 'helpers/selected_inidcator.dart';

abstract class GridObject extends InfiniteCanvasObject {
  GridObject({
    super.position,
    super.color,
    super.scale,
    super.size,
    super.rotation,
    super.id,
    super.objectType = InfiniteCanvasObjectType.gridObject,
  });

  @override
  void draw(
    Canvas canvas,
    Paint paint,
    Offset canvasOffset,
    double gridSize,
    double scale,
  ) {
    canvas.save();
    canvas.translate(canvasOffset.dx, canvasOffset.dy);
    canvas.scale(scale);
    canvas.translate(
      (position.dx / gridSize).round() * gridSize,
      (position.dy / gridSize).round() * gridSize,
    );
    canvas.rotate(rotation * (math.pi / 180));

    final rect = Rect.fromLTWH(
      0,
      0,
      size.width * gridSize,
      size.height * gridSize,
    );

    paint.color = color;
    canvas.drawRect(rect, paint);

    const radius = Radius.circular(4);
    paint.style = PaintingStyle.fill;
    canvas.drawRRect(RRect.fromRectAndRadius(rect, radius), paint);

    // Dibujar el borde
    Paint borderPaint = getSelectedIndicatorPaint(color, selected);
    canvas.drawRRect(RRect.fromRectAndRadius(rect, radius), borderPaint);

    drawContent(canvas, paint, rect, canvasOffset, gridSize, scale);

    canvas.restore();
  }

  void drawContent(Canvas canvas, Paint paint, Rect rect, Offset canvasOffset,
      double gridSize, double scale);

  @override
  bool contains(
    Offset point,
    Offset canvasOffset,
    double gridSize,
    double scale,
  ) {
    final transformedPoint = (point - canvasOffset) / scale;
    final rotatedPoint = rotatePoint(transformedPoint - position, -rotation);
    return rotatedPoint.dx >= 0 &&
        rotatedPoint.dx <= size.width * gridSize &&
        rotatedPoint.dy >= 0 &&
        rotatedPoint.dy <= size.height * gridSize;
  }
}


file: -- models\helpers\selected_inidcator.dart
import 'package:flutter/material.dart';

Paint getSelectedIndicatorPaint(Color color, bool isSelected) {
  final borderColor = isSelected ? const Color.fromARGB(255, 104, 81, 247) : color;

  final paint = Paint()
    ..color = borderColor.withAlpha(isSelected ? 255 : 255)
    ..style = PaintingStyle.stroke
    ..strokeWidth = isSelected ? 2.5 : 1.5; // Grosor del borde

  // Agregar sombra si está seleccionado
  if (isSelected) {
    paint.maskFilter = const MaskFilter.blur(BlurStyle.solid, 5); // Efecto de sombra
  }

  return paint;
}

file: -- models\signage_object.dart
import 'package:flutter/material.dart';
import 'dart:math' as math;

import 'grid_object.dart';
import 'helpers/selected_inidcator.dart';

enum SignageObjectType { exit, entrance, via }

enum SignageObjectDirection { left, right, up, down }

SignageObjectType intToSignageObjectType(int value) {
  if (value >= 0 && value < SignageObjectType.values.length) {
    return SignageObjectType.values[value];
  } else {
    return SignageObjectType.entrance;
  }
}

class SignageObject extends GridObject {
  final SignageObjectType type;
  SignageObjectDirection direction;

  // Tamaños predefinidos para cada tipo de señal
  static const Map<SignageObjectType, Size> signalSizes = {
    SignageObjectType.exit: Size(6, 2), // 6x2 metros
    SignageObjectType.entrance: Size(6, 2), // 6x2 metros
    SignageObjectType.via: Size(6, 2), // 6x2 metros
  };

  // Colores predefinidos para cada tipo de señal (Material 3)
  static const Map<SignageObjectType, Color> signalColors = {
    SignageObjectType.exit: Colors.red, // Rojo para salida
    SignageObjectType.entrance: Colors.green, // Verde para entrada
    SignageObjectType.via: Colors.blue, // Azul para via
  };

  // Etiquetas predefinidas para cada tipo de señal
  static const Map<SignageObjectType, String> signalLabels = {
    SignageObjectType.exit: 'Salida',
    SignageObjectType.entrance: 'Entrada',
    SignageObjectType.via: 'Via',
  };

  SignageObject({
    required this.type,
    this.direction = SignageObjectDirection.right,
    super.position = const Offset(0, 0),
    super.id,
  }) : super(
          size: Size(signalSizes[type]!.width, signalSizes[type]!.height),
          color: signalColors[type]!,
        );

  // Getter para obtener la etiqueta automáticamente
  String get label => signalLabels[type]!;

  @override
  void drawContent(Canvas canvas, Paint paint, Rect rect, Offset canvasOffset,
      double gridSize, double scale) {
    // Dibujar las dos franjas horizontales
    _drawHorizontalStripes(canvas, rect);

    // Dibujar el ícono y el label (si no es de tipo "via")
    _drawIconAndLabel(canvas, rect);
  }

  void toggleDirection() {
    if (direction == SignageObjectDirection.right) {
      direction = SignageObjectDirection.left;
    } else {
      direction = SignageObjectDirection.right;
    }
  }

  void _drawHorizontalStripes(Canvas canvas, Rect rect) {
    final stripeHeight = rect.height * 0.1; // 10% del alto del rectángulo
    final margin =
        rect.width * 0.1; // 10% de margen en los lados izquierdo y derecho

    // Franja superior
    final topStripeRect = Rect.fromLTWH(
      margin, // Margen izquierdo
      rect.height * 0.15, // Margen superior (15%)
      rect.width - 2 * margin, // Ancho del rectángulo menos los márgenes
      stripeHeight, // Altura de la franja
    );
    canvas.drawRect(topStripeRect, Paint()..color = Colors.white);

    // Franja inferior
    final bottomStripeRect = Rect.fromLTWH(
      margin, // Margen izquierdo
      rect.height - rect.height * 0.15 - stripeHeight, // Margen inferior (15%)
      rect.width - 2 * margin, // Ancho del rectángulo menos los márgenes
      stripeHeight, // Altura de la franja
    );
    canvas.drawRect(bottomStripeRect, Paint()..color = Colors.white);
  }

  void _drawIconAndLabel(Canvas canvas, Rect rect) {
    // Tamaño del ícono
    final iconSize = rect.height * 0.85; // 85% del alto del rectángulo

    // Crear un TextPainter para dibujar el ícono (flecha)
    final iconPainter = TextPainter(
      text: TextSpan(
        text: String.fromCharCode(Icons.arrow_right_alt.codePoint),
        style: TextStyle(
          fontSize: iconSize,
          fontFamily: Icons.arrow_right_alt.fontFamily,
          color: Colors.white, // Color del ícono
        ),
      ),
      textDirection: TextDirection.ltr,
    );
    iconPainter.layout();

    // Rotación del ícono según la dirección
    final iconRotation = _getIconRotation();

    // Calcular la posición del ícono
    final iconOffset = _getIconOffset(rect, iconPainter);

    // Dibujar el ícono rotado
    canvas.save();
    canvas.translate(iconOffset.dx + iconPainter.width / 2,
        iconOffset.dy + iconPainter.height / 2);
    canvas.rotate(iconRotation);
    canvas.translate(-iconPainter.width / 2, -iconPainter.height / 2);
    iconPainter.paint(canvas, Offset.zero);
    canvas.restore();

    // Si no es de tipo "via", dibujar el label
    if (type != SignageObjectType.via) {
      _drawLabel(canvas, rect, iconPainter);
    }
  }

  void _drawLabel(Canvas canvas, Rect rect, TextPainter iconPainter) {
    // Tamaño del texto
    final textSize = rect.height * 0.35; // 35% del alto del rectángulo

    // Crear un TextPainter para dibujar la etiqueta
    final textPainter = TextPainter(
      text: TextSpan(
        text: label,
        style: TextStyle(
          color: Colors.white, // Texto en blanco
          fontSize: textSize,
          fontWeight: FontWeight.bold,
          shadows: [
            Shadow(
              color: Colors.black
                  .withOpacity(0.5), // Sombra para mejorar la legibilidad
              blurRadius: 2,
              offset: const Offset(1, 1),
            ),
          ],
        ),
      ),
      textDirection: TextDirection.ltr,
    );
    textPainter.layout();

    // Calcular la posición del texto según la dirección
    final textOffset = _getLabelOffset(rect, textPainter, iconPainter);

    // Dibujar el texto
    textPainter.paint(canvas, textOffset);
  }

  Offset _getIconOffset(Rect rect, TextPainter iconPainter) {
    switch (direction) {
      case SignageObjectDirection.left:
        return Offset(
          rect.width * 0.1, // Margen izquierdo
          (rect.height - iconPainter.height) / 2, // Centrar verticalmente
        );
      case SignageObjectDirection.right:
        return Offset(
          rect.width - iconPainter.width - rect.width * 0.1, // Margen derecho
          (rect.height - iconPainter.height) / 2, // Centrar verticalmente
        );
      case SignageObjectDirection.up:
      case SignageObjectDirection.down:
        return Offset(
          (rect.width - iconPainter.width) / 2, // Centrar horizontalmente
          (rect.height - iconPainter.height) / 2, // Centrar verticalmente
        );
    }
  }

  Offset _getLabelOffset(
      Rect rect, TextPainter textPainter, TextPainter iconPainter) {
    final padding =
        rect.width * 0.05; // 5% de padding entre el ícono y el texto

    switch (direction) {
      case SignageObjectDirection.left:
        return Offset(
          rect.width - textPainter.width - rect.width * 0.1, // Margen derecho
          (rect.height - textPainter.height) / 2, // Centrar verticalmente
        );
      case SignageObjectDirection.right:
        return Offset(
          rect.width * 0.1, // Margen izquierdo
          (rect.height - textPainter.height) / 2, // Centrar verticalmente
        );
      case SignageObjectDirection.up:
        return Offset(
          rect.width - textPainter.width - rect.width * 0.1, // Margen derecho
          (rect.height - textPainter.height) / 2, // Centrar verticalmente
        );
      case SignageObjectDirection.down:
        return Offset(
          rect.width * 0.1, // Margen izquierdo
          (rect.height - textPainter.height) / 2, // Centrar verticalmente
        );
    }
  }

  double _getIconRotation() {
    switch (direction) {
      case SignageObjectDirection.left:
        return math.pi; // 180 grados (apunta a la izquierda)
      case SignageObjectDirection.right:
        return 0; // 0 grados (apunta a la derecha)
      case SignageObjectDirection.up:
        return -math.pi / 2; // -90 grados (apunta hacia arriba)
      case SignageObjectDirection.down:
        return math.pi / 2; // 90 grados (apunta hacia abajo)
    }
  }
}


file: -- models\spot_object.dart
import 'package:flutter/material.dart';
import 'dart:math' as math;
import 'package:flutter/services.dart'; // Para cargar imágenes desde assets
import 'dart:ui' as ui; // Para usar ui.Image
import 'grid_object.dart';
import 'helpers/selected_inidcator.dart';

enum SpotObjectType { car, bus, truck, van, motorcycle, bicycle }

enum SpotObjectCategory { standart, vip, electric, handicap }

SpotObjectType intToSpotObjectType(int value) {
  if (value >= 0 && value < SpotObjectType.values.length) {
    return SpotObjectType.values[value];
  } else {
    return SpotObjectType.car;
  }
}

SpotObjectCategory intToSpotObjectCategory(int value) {
  if (value >= 0 && value < SpotObjectCategory.values.length) {
    return SpotObjectCategory.values[value];
  } else {
    return SpotObjectCategory.standart;
  }
}

class SpotObject extends GridObject {
  final SpotObjectType type;
  final SpotObjectCategory category;
  String label; // Código del spot (ejemplo: A4)
  bool isFree;
  Color? tintColor; // Nuevo: Color para aplicar a la imagen
  String? vehiclePlate; // Placa del vehículo (null si está libre)

  // Tamaños predefinidos para cada tipo de spot
  static const Map<SpotObjectType, Size> spotSizes = {
    SpotObjectType.car: Size(2 * 2, 4 * 2),
    SpotObjectType.bus: Size(2.5 * 2, 12 * 2),
    SpotObjectType.truck: Size(2.5 * 2, 8 * 2),
    SpotObjectType.van: Size(2 * 2, 5 * 2),
    SpotObjectType.motorcycle: Size(1 * 2, 2 * 2),
    SpotObjectType.bicycle: Size(5 * 2, 1.5 * 2),
  };

  // Colores predefinidos para cada categoría
  static const Map<SpotObjectCategory, Color> categoryColors = {
    SpotObjectCategory.standart: Color(0xFF4A90E2), // Azul suave
    SpotObjectCategory.vip: Color(0xFFDAA520), // Dorado
    SpotObjectCategory.electric: Color(0xFF32CD32), // Verde lima
    SpotObjectCategory.handicap: Color(0xFFFF6347), // Coral
  };

  // Nombres de las imágenes locales para cada tipo de spot
  static const Map<SpotObjectType, String> spotImages = {
    SpotObjectType.car: 'assets/spot/Car.png',
    SpotObjectType.bus: 'assets/spot/Mini_van.png',
    SpotObjectType.truck: 'assets/spot/Truck.png',
    SpotObjectType.van: 'assets/spot/Mini_van.png',
    SpotObjectType.motorcycle: 'assets/spot/Truck.png',
    SpotObjectType.bicycle: 'assets/spot/Truck.png',
  };

  // Mapa para almacenar las imágenes cargadas
  static final Map<SpotObjectType, ui.Image> _loadedImages = {};

  SpotObject({
    super.position = const Offset(0, 0),
    required this.label, // Código del spot (ejemplo: A4)
    this.isFree = true,
    this.tintColor, // Nuevo: Color para aplicar a la imagen
    this.vehiclePlate, // Placa del vehículo (null si está libre)
    required this.type,
    required this.category,
    super.id,
  }) : super(
          size: Size(spotSizes[type]!.width, spotSizes[type]!.height),
          color: categoryColors[category]!,
        );

  // Método para cargar las imágenes (debe llamarse antes de usar los objetos)
  static Future<void> loadImages() async {
    for (final entry in spotImages.entries) {
      final imagePath = entry.value;
      final ByteData imageData = await rootBundle.load(imagePath);
      final codec =
          await ui.instantiateImageCodec(imageData.buffer.asUint8List());
      final frame = await codec.getNextFrame();
      _loadedImages[entry.key] = frame.image;
    }
  }

  @override
  void drawContent(
    Canvas canvas,
    Paint paint,
    Rect rect,
    Offset canvasOffset,
    double gridSize,
    double scale,
  ) {
    // Dibujar la imagen solo si el spot está ocupado
    if (!isFree) {
      _drawSpotImage(canvas, rect, tintColor: tintColor);
    }

    // Dibujar el texto
    _drawLabel(canvas, rect);
  }

  void toggleStatus() {
    isFree = !isFree;
  }

  void _drawSpotImage(Canvas canvas, Rect rect,
      {Color? tintColor = Colors.blue}) {
    final image = _loadedImages[type]; // Obtener la imagen cargada
    if (image == null) return; // Si la imagen no está cargada, no hacer nada

    // Calcular la relación de aspecto de la imagen original
    final imageAspectRatio = image.width / image.height;

    // Calcular el tamaño máximo que la imagen puede tener dentro del rectángulo
    final maxImageWidth = rect.width * 0.95; // 95% del ancho del rectángulo
    final maxImageHeight = rect.height * 0.95; // 95% del alto del rectángulo

    // Calcular el tamaño de la imagen respetando su relación de aspecto
    double imageWidth, imageHeight;
    if (maxImageWidth / maxImageHeight > imageAspectRatio) {
      // Si el espacio disponible es más ancho que la imagen, ajustar por altura
      imageHeight = maxImageHeight;
      imageWidth = imageHeight * imageAspectRatio;
    } else {
      // Si el espacio disponible es más alto que la imagen, ajustar por ancho
      imageWidth = maxImageWidth;
      imageHeight = imageWidth / imageAspectRatio;
    }

    // Calcular la posición de la imagen (centrada horizontalmente y verticalmente)
    final imageOffset = Offset(
      (rect.width - imageWidth) / 2, // Centrar horizontalmente
      (rect.height - imageHeight) / 2, // Centrar verticalmente
    );

    // Dibujar la imagen original primero
    canvas.drawImageRect(
      image,
      Rect.fromLTWH(0, 0, image.width.toDouble(), image.height.toDouble()),
      Rect.fromLTWH(imageOffset.dx, imageOffset.dy, imageWidth, imageHeight),
      Paint(),
    );

    // Si se proporciona un tintColor, aplicar un filtro solo a los colores naranja y rojo
    if (tintColor != null) {
      // Crear una máscara para los colores naranja y rojo
      final maskPaint = Paint()
        ..colorFilter = ColorFilter.mode(tintColor, BlendMode.srcIn)
        ..blendMode = BlendMode.srcIn;

      // Dibujar la imagen nuevamente, pero solo los píxeles que coincidan con la máscara
      canvas.saveLayer(
        Rect.fromLTWH(imageOffset.dx, imageOffset.dy, imageWidth, imageHeight),
        maskPaint,
      );
      canvas.drawImageRect(
        image,
        Rect.fromLTWH(0, 0, image.width.toDouble(), image.height.toDouble()),
        Rect.fromLTWH(imageOffset.dx, imageOffset.dy, imageWidth, imageHeight),
        Paint()
          ..colorFilter = ColorFilter.mode(
            Colors.white
                .withOpacity(0.5), // Ajusta la opacidad según sea necesario
            BlendMode.srcIn,
          ),
      );
      canvas.restore();
    }
  }

  void _drawLabel(Canvas canvas, Rect rect) {
    // Texto del código del spot (label)
    final spotCodePainter = TextPainter(
      text: TextSpan(
        text: label, // Código del spot (ejemplo: A4)
        style: const TextStyle(
          color: Colors.white, // Texto en blanco
          fontSize: 12,
          fontWeight: FontWeight.bold,
        ),
      ),
      textDirection: TextDirection.ltr,
    );
    spotCodePainter.layout();

    // Texto de la placa o "LIBRE"
    final plateOrFreePainter = TextPainter(
      text: TextSpan(
        text: isFree ? "LIBRE" : vehiclePlate ?? "", // Placa o "LIBRE"
        style: const TextStyle(
          color: Colors.white,
          fontSize: 10,
          fontWeight: FontWeight.bold,
        ),
      ),
      textDirection: TextDirection.ltr,
    );
    plateOrFreePainter.layout();

    // Posicionamiento del texto
    if (isFree) {
      // Si el spot está libre, centrar ambos textos
      final totalHeight = spotCodePainter.height +
          plateOrFreePainter.height +
          4; // Espacio entre textos
      final startY = (rect.height - totalHeight) / 2;

      // Dibujar el código del spot
      spotCodePainter.paint(
        canvas,
        Offset(
          (rect.width - spotCodePainter.width) / 2,
          startY,
        ),
      );

      // Dibujar "LIBRE"
      plateOrFreePainter.paint(
        canvas,
        Offset(
          (rect.width - plateOrFreePainter.width) / 2,
          startY + spotCodePainter.height + 4, // Espacio entre textos
        ),
      );
    } else {
      // Si el spot está ocupado, el código del spot va arriba y la placa abajo
      spotCodePainter.paint(
        canvas,
        Offset(
          (rect.width - spotCodePainter.width) / 2,
          rect.height * 0.1, // Espacio desde la parte superior
        ),
      );

      plateOrFreePainter.paint(
        canvas,
        Offset(
          (rect.width - plateOrFreePainter.width) / 2,
          rect.height * 0.85, // Espacio desde la parte superior
        ),
      );
    }
  }
}


file: -- models\text_object.dart
import 'package:flutter/material.dart';
import 'canvas_object.dart';
import 'dart:math' as math;

/// Objeto que representa un texto.
class TextObject extends InfiniteCanvasObject {
  String text;
  TextStyle style;

  TextObject({
    required super.position,
    required this.text,
    required super.color,
    this.style = const TextStyle(color: Colors.black, fontSize: 16),
    super.id,
    super.objectType = InfiniteCanvasObjectType.text,
  });

  @override
  void draw(Canvas canvas, Paint paint, Offset canvasOffset, double scale,
      double gridSize) {
    canvas.save();
    canvas.translate(canvasOffset.dx, canvasOffset.dy);
    canvas.scale(scale);
    canvas.translate(
      (position.dx / gridSize).round() * gridSize,
      (position.dy / gridSize).round() * gridSize,
    );
    canvas.rotate(rotation * (math.pi / 180));

    final textPainter = TextPainter(
      text: TextSpan(text: text, style: style),
      textDirection: TextDirection.ltr,
    );
    textPainter.layout();
    textPainter.paint(canvas, Offset.zero);

    canvas.restore();
  }

  @override
  Size get size {
    // Calcular el tamaño del texto usando un TextPainter
    final textPainter = TextPainter(
      text: TextSpan(text: text, style: style),
      textDirection: TextDirection.ltr,
    );
    textPainter.layout();
    return textPainter.size;
  }

  @override
  bool contains(
      Offset point, Offset canvasOffset, double scale, double gridSize) {
    final transformedPoint = (point - canvasOffset) / scale;
    final rotatedPoint = rotatePoint(transformedPoint - position, -rotation);
    final textPainter = TextPainter(
      text: TextSpan(text: text, style: TextStyle(color: color, fontSize: 16)),
      textDirection: TextDirection.ltr,
    );
    textPainter.layout();
    return rotatedPoint.dx >= 0 &&
        rotatedPoint.dx <= textPainter.width &&
        rotatedPoint.dy >= 0 &&
        rotatedPoint.dy <= textPainter.height;
  }
}


file: -- widgets\canvas.dart
// ignore_for_file: avoid_single_cascade_in_expression_statements

import 'package:flutter/gestures.dart';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:parkar/infinite_canvas/widgets/tools/mode_bar.dart';
import '../models/spot_object.dart';
import 'canvas_controller.dart';
import 'canvas_painter.dart';
import 'tools/grid_object_bar.dart';
import 'tools/action_bar.dart';
import 'mini_map/mini_map.dart';
import 'tools/floating_buttons.dart';

class InfiniteCanvas extends StatefulWidget {
  final InfiniteCanvasController? controller;
  final double gridSize; // Tamaño de la cuadrícula en píxeles
  final bool isEditable;

  const InfiniteCanvas({
    super.key,
    this.controller,
    this.gridSize = 15, // Tamaño de la cuadrícula en píxeles
    this.isEditable = true,
  });

  @override
  State<InfiniteCanvas> createState() => _InfiniteCanvasState();
}

class _InfiniteCanvasState extends State<InfiniteCanvas> {
  late InfiniteCanvasController controller;
  late Size viewportSize;

  @override
  void initState() {
    super.initState();
    SpotObject.loadImages().then((_) {
      setState(
          () {}); // Actualizar el estado cuando las imágenes estén cargadas
    });
    controller = widget.controller ?? InfiniteCanvasController();
    controller.setGridSize(widget.gridSize);
    controller.addListener(_onControllerChanged);
  }

  @override
  void dispose() {
    controller.removeListener(_onControllerChanged);
    super.dispose();
  }

  @override
  void didChangeDependencies() {
    super.didChangeDependencies();
    viewportSize = MediaQuery.of(context).size;
    controller.updateViewportSize(viewportSize);
  }

  void _onControllerChanged() {
    setState(() {});
  }

  Map<Type, GestureRecognizerFactory> _buildGestures() {
    return {
      PanGestureRecognizer:
          GestureRecognizerFactoryWithHandlers<PanGestureRecognizer>(
        () => PanGestureRecognizer(),
        (PanGestureRecognizer instance) {
          instance
            ..onStart = controller.onPanStart
            ..onUpdate = controller.onPanUpdate
            ..onEnd = controller.onPanEnd;
        },
      ),
      ScaleGestureRecognizer:
          GestureRecognizerFactoryWithHandlers<ScaleGestureRecognizer>(
        () => ScaleGestureRecognizer(),
        (ScaleGestureRecognizer instance) {
          instance
            ..onStart = controller.onScaleStart
            ..onUpdate = controller.onScaleUpdate
            ..onEnd = controller.onScaleEnd;
        },
      ),
      TapGestureRecognizer:
          GestureRecognizerFactoryWithHandlers<TapGestureRecognizer>(
        () => TapGestureRecognizer(),
        (TapGestureRecognizer instance) {
          instance
            ..onTapDown = (details) {
              final position =
                  (details.localPosition - controller.canvasOffset) /
                      controller.zoom;
              if (controller.canvasMode == DrawingMode.text) {
                _showEditTextDialog(position);
              } else {
                controller.selectObject(position);
              }
            };
        },
      ),
    };
  }

  void _showEditTextDialog(Offset position) {
    final textController = TextEditingController();
    showDialog(
      context: context,
      builder: (BuildContext context) {
        return AlertDialog(
          title: const Text("Agregar texto"),
          content: TextField(
            controller: textController,
            decoration: const InputDecoration(hintText: "Escribe algo..."),
          ),
          actions: [
            TextButton(
              onPressed: () {
                controller.addText(position, textController.text);
                Navigator.of(context).pop();
              },
              child: const Text("Agregar"),
            ),
          ],
        );
      },
    );
  }

  @override
  Widget build(BuildContext context) {
    return Shortcuts(
      shortcuts: {
        LogicalKeySet(LogicalKeyboardKey.control, LogicalKeyboardKey.keyC):
            CopyCommand(),
        LogicalKeySet(LogicalKeyboardKey.control, LogicalKeyboardKey.keyV):
            PasteCommand(),
        LogicalKeySet(LogicalKeyboardKey.delete): DeleteCommand(),
      },
      child: Actions(
        actions: {
          CopyCommand: CallbackAction<CopyCommand>(
              onInvoke: (_) => controller.copySelectedObjects()),
          PasteCommand: CallbackAction<PasteCommand>(
              onInvoke: (_) => controller.pasteObjects()),
          DeleteCommand: CallbackAction<DeleteCommand>(
              onInvoke: (_) => controller.deleteSelectedObjects()),
        },
        child: Scaffold(
          body: Stack(
            children: [
              Listener(
                onPointerSignal: (pointerSignal) {
                  if (pointerSignal is PointerScrollEvent) {
                    controller.adjustZoom(pointerSignal.scrollDelta.dy < 0);
                  }
                },
                child: RawGestureDetector(
                  gestures: _buildGestures(),
                  child: CustomPaint(
                    size: Size.infinite,
                    painter: InfiniteCanvasPainter(
                      controller: controller,
                      gridColor: Theme.of(context)
                          .colorScheme
                          .onSurface
                          .withAlpha(128),
                    ),
                  ),
                ),
              ),
              // MiniMap(
              //   controller: controller,
              //   viewportSize: MediaQuery.of(context).size,
              // ),
              Positioned(
                top: 100,
                right: 10,
                child: GridObjectBar(
                  controller: controller,
                  orientation: Axis.horizontal,
                ),
              ),
              if (controller.selectedObjects.isNotEmpty && widget.isEditable)
                ActionBar(controller: controller),
              FloatingButtons(controller: controller),
              Positioned(
                bottom: 10,
                left: 10,
                child: Container(
                  padding: const EdgeInsets.all(8),
                  child: const Text(
                    "Escala: 0.5m/cuadro",
                    style: TextStyle(fontSize: 10, fontWeight: FontWeight.w600),
                  ),
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }
}

class CopyCommand extends Intent {}

class PasteCommand extends Intent {}

class DeleteCommand extends Intent {}


file: -- widgets\canvas_controller.dart
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:parkar/infinite_canvas/models/signage_object.dart';
import 'package:uuid/uuid.dart';
import '../models/free_form_object.dart';
import '../models/canvas_object.dart';
import '../models/grid_object.dart';
import '../models/text_object.dart';
import '../models/spot_object.dart';

enum DrawingMode { gridObject, text }

class InfiniteCanvasController extends ChangeNotifier {
  final List<InfiniteCanvasObject> _objects = [];
  final List<InfiniteCanvasObject> _selectedObjects = [];
  final List<InfiniteCanvasObject> _changedObjects = [];
  final ValueNotifier<int> objectCountNotifier = ValueNotifier(0);
  final ValueNotifier<int> changesCountNotifier = ValueNotifier(0);
  final ValueNotifier<bool> _isAnimating = ValueNotifier(false); // Control de animación

  ValueNotifier<bool> get isAnimating => _isAnimating;
  DrawingMode _canvasMode = DrawingMode.gridObject;
  double _zoom = 1.0;
  Offset _canvasOffset = Offset.zero;
  final List<Offset> _freeFormPoints = [];
  Offset? _dragStart;
  Offset? _objectDragStart;
  double _gridSize = 15.0;
  bool _showGrid = false;
  Size viewportSize = Size.zero;

  // Callbacks
  VoidCallback? onChanged;
  VoidCallback? onSelect;
  Function(String message)? onShowMessage; // Para mostrar mensajes (SnackBar)

  // Objeto copiado
  InfiniteCanvasObject? _copiedObject;

  List<InfiniteCanvasObject> get objects => _objects;
  List<InfiniteCanvasObject> get selectedObjects => _selectedObjects;
  List<InfiniteCanvasObject> get changedObjects => _changedObjects;
  DrawingMode get canvasMode => _canvasMode;
  double get zoom => _zoom;
  Offset get canvasOffset => _canvasOffset;
  List<Offset> get freeFormPoints => _freeFormPoints;
  double get gridSize => _gridSize;
  bool get showGrid => _showGrid;

  // Método para agregar/actualizar objetos modificados
  void _addToChangedObjects(InfiniteCanvasObject object) {
    final index = _changedObjects.indexWhere((o) => o.id == object.id);
    if (index != -1) {
      _changedObjects[index] = object; // Reemplaza si ya existe
    } else {
      _changedObjects.add(object); // Agrega si es nuevo
    }
    changesCountNotifier.value = _changedObjects.length;
    onChanged?.call();
  }

  // Método para manejar atajos de teclado
  void handleKeyEvent(RawKeyEvent event) {
    if (event.isControlPressed) {
      if (event.logicalKey == LogicalKeyboardKey.keyC) {
        _copySelectedObjects();
      } else if (event.logicalKey == LogicalKeyboardKey.keyV) {
        _pasteObject();
      }
    } else if (event.logicalKey == LogicalKeyboardKey.delete) {
      deleteSelectedObjects();
    }
  }

  // Copiar objetos seleccionados
  void _copySelectedObjects() {
    if (_selectedObjects.isNotEmpty) {
      _copiedObject = _selectedObjects.first;
      onShowMessage?.call('Objeto copiado'); // Notificar al padre
    }
  }

  // Pegar objeto copiado
  void _pasteObject() {
    if (_copiedObject != null) {
      // Crear una copia del objeto con un nuevo ID
      // final newObject = _copiedObject!.copyWith(
      //   id: const Uuid().v4(), // Nuevo ID único
      //   position: _copiedObject!.position + const Offset(20, 20), // Desplazamiento
      // );

      // // Agregar el nuevo objeto al lienzo
      // _objects.add(newObject);
      // _selectedObjects.clear();
      // _selectedObjects.add(newObject);
      // _addToChangedObjects(newObject);
      // notifyListeners();
    }
  }

  void setShowGrid(bool showGrid) {
    _showGrid = showGrid;
    notifyListeners();
  }

  void setCanvasMode(DrawingMode mode) {
    _canvasMode = mode;
    notifyListeners();
  }

  void setGridSize(double gridSize) {
    _gridSize = gridSize;
    notifyListeners();
  }

  void adjustZoom(bool zoomIn) {
    _zoom = (zoomIn ? _zoom * 1.2 : _zoom / 1.2).clamp(0.1, 5.0);
    notifyListeners();
  }

  void onPanStart(DragStartDetails details) {
    _dragStart = details.localPosition;
    if (_selectedObjects.isNotEmpty) {
      _objectDragStart = _selectedObjects.first.position;
    }
    notifyListeners();
  }

  void onPanUpdate(DragUpdateDetails details) {
    final delta = (details.localPosition - _dragStart!) / _zoom;
    if (_selectedObjects.isNotEmpty && _objectDragStart != null) {
      final newPosition = _objectDragStart! + delta;
      bool canMove = true;
      for (var object in _objects) {
        if (object != _selectedObjects.first &&
            _checkCollision(_selectedObjects.first, newPosition, object)) {
          canMove = false;
          break;
        }
      }
      if (canMove) {
        for (var object in _selectedObjects) {
          object.position = newPosition;
        }
      }
    } else {
      _canvasOffset += delta;
      _dragStart = details.localPosition;
    }
    notifyListeners();
  }

  void onPanEnd(DragEndDetails details) {
    _dragStart = null;
    _objectDragStart = null;
    notifyListeners();
  }

  void onScaleStart(ScaleStartDetails details) {
    _dragStart = details.focalPoint;
  }

  void onScaleUpdate(ScaleUpdateDetails details) {
    if (details.scale != 1.0) {
      final oldZoom = _zoom;
      _zoom *= details.scale;
      _zoom = _zoom.clamp(0.1, 5.0);

      final focalPoint = details.focalPoint;
      final zoomFactor = _zoom / oldZoom;
      _canvasOffset = focalPoint - (focalPoint - _canvasOffset) * zoomFactor;
    } else {
      _canvasOffset += details.focalPoint - _dragStart!;
      _dragStart = details.focalPoint;
    }
    notifyListeners();
  }

  void onScaleEnd(ScaleEndDetails details) {
    _dragStart = null;
    notifyListeners();
  }

  void onTapDown(TapDownDetails details) {
    final canvasPosition = (details.localPosition - _canvasOffset) / _zoom;
    if (_canvasMode == DrawingMode.gridObject) {
      selectObject(canvasPosition);
    }
    notifyListeners();
  }

  void selectObject(Offset position) {
    _selectedObjects.clear();
    for (var object in _objects.reversed) {
      if (object.contains(
        position,
        Offset.zero,
        _gridSize,
        1.0,
      )) {
        _selectedObjects.add(object);
        break;
      }
    }
    notifyListeners();
  }

  bool _checkCollision(InfiniteCanvasObject object1, Offset newPosition,
      InfiniteCanvasObject object2) {
    if (object1 is GridObject && object2 is GridObject) {
      final rect1 = Rect.fromLTWH(
        newPosition.dx,
        newPosition.dy,
        object1.size.width * _gridSize,
        object1.size.height * _gridSize,
      );
      final rect2 = Rect.fromLTWH(
        object2.position.dx,
        object2.position.dy,
        object2.size.width * _gridSize,
        object2.size.height * _gridSize,
      );
      return rect1.overlaps(rect2);
    }
    return false;
  }

  Offset getCenterOfView(Size viewportSize) {
    return Offset(
      (viewportSize.width / 2 - _canvasOffset.dx) / _zoom,
      (viewportSize.height / 2 - _canvasOffset.dy) / _zoom,
    );
  }

  void addGridObjectNode(GridObject object) {
    Offset offset = getCenterOfView(viewportSize);
    bool positionFound = false;

    // Ajustar el offset para que el objeto esté centrado en la vista
    offset -= Offset(
        object.size.width * _gridSize / 2, object.size.height * _gridSize / 2);

    // Verificar si hay colisión en el centro de la vista
    positionFound = true;
    for (var existingObject in _objects) {
      if (existingObject is GridObject &&
          _checkCollision(object, offset, existingObject)) {
        positionFound = false;
        break;
      }
    }

    // Si no hay espacio en el centro de la vista, buscar espacio a la derecha e inferior
    if (!positionFound) {
      offset = Offset(offset.dx + object.size.width * _gridSize,
          offset.dy + object.size.height * _gridSize);
      while (!positionFound) {
        positionFound = true;
        for (var existingObject in _objects) {
          if (existingObject is GridObject &&
              _checkCollision(object, offset, existingObject)) {
            positionFound = false;
            offset =
                Offset(offset.dx + object.size.width * _gridSize, offset.dy);
            break;
          }
        }
      }
    }

    object.position = offset;
    _selectedObjects.clear();
    _selectedObjects.add(object);
    _objects.add(object);
        _isAnimating.value = true;
    Future.delayed(const Duration(milliseconds: 150), () {
      _isAnimating.value = false; // Finalizar animación después de 300ms
    });
    
    notifyListeners();
  }

  void addText(Offset position, String text) {
    final textObject = TextObject(
      position: position,
      text: text,
      color: Colors.black,
    );
    _objects.add(textObject);
    _selectedObjects.clear();
    _selectedObjects.add(textObject);
    notifyListeners();
  }

  void deleteSelectedObjects() {
    _objects.removeWhere((object) => _selectedObjects.contains(object));
    _selectedObjects.clear();
    notifyListeners();
  }

  void rotateSelectedObjects(double angle) {
    for (var object in _selectedObjects) {
      object.rotate(angle);
    }
    notifyListeners();
  }

  void toggleSignageDirection() {
    if (_selectedObjects.firstOrNull is SignageObject) {
      final selectedVehicle = _selectedObjects.first as SignageObject;
      selectedVehicle.toggleDirection();
      notifyListeners();
    }
  }

  void toggleSpotStatus() {
    if (_selectedObjects.firstOrNull is SpotObject) {
      final selectedVehicle = _selectedObjects.first as SpotObject;
      selectedVehicle.toggleStatus();
      notifyListeners();
    }
  }

  void editSelectedText() {
    if (_selectedObjects.isNotEmpty && _selectedObjects.first is TextObject) {
      final selectedTextObject = _selectedObjects.first as TextObject;
      // Implementar lógica para editar texto
      notifyListeners();
    }
  }

  void centerCanvas() {
    _canvasOffset = Offset.zero;
    notifyListeners();
  }

  void resetZoom() {
    _zoom = 1.0;
    notifyListeners();
  }

  void copySelectedObjects() {
    // Implementar lógica para copiar objetos
    notifyListeners();
  }

  void pasteObjects() {
    // Implementar lógica para pegar objetos
    notifyListeners();
  }

  void updateCanvasOffset(double dx, double dy) {
    _canvasOffset = Offset(dx, dy);
    notifyListeners();
  }

  void updateViewportSize(Size newSize) {
    viewportSize = newSize;
    notifyListeners();
  }
}


file: -- widgets\canvas_painter.dart
import 'package:flutter/material.dart';
import 'package:parkar/infinite_canvas/widgets/canvas_controller.dart';
import '../models/canvas_object.dart';
import '../models/grid_object.dart';

/// Pintor personalizado para el lienzo.
class InfiniteCanvasPainter extends CustomPainter {
  final InfiniteCanvasController controller;
  final Color gridColor;

  InfiniteCanvasPainter({
    required this.gridColor,
    required this.controller,
  });

@override
  void paint(Canvas canvas, Size size) {
    canvas.save();
    canvas.translate(controller.canvasOffset.dx, controller.canvasOffset.dy);
    canvas.scale(controller.zoom);

    if (controller.showGrid) {
      _drawGrid(canvas, size);
    }

    for (var object in controller.objects) {
      if (controller.selectedObjects.lastOrNull == object) {
        if (object is GridObject) {
          object.selected = true;
        }
      } else {
        if (object is GridObject) {
          object.selected = false;
        }
      }

      // Dibujar el objeto con animación de movimiento
      if (controller.isAnimating.value && object == controller.objects.last) {
        final startPosition = Offset(size.width / 2, size.height / 2); // Centro de la pantalla
        final endPosition = object.position;

        // Interpolación lineal para la posición
        final animatedPosition = Offset.lerp(startPosition, endPosition, 0.5)!;

        object.draw(canvas, Paint()..color = object.color, animatedPosition, controller.gridSize, 1.0);
      } else {
        object.draw(canvas, Paint()..color = object.color, Offset.zero, controller.gridSize, 1.0);
      }
    }

    canvas.restore();
  }
  void _drawGrid(Canvas canvas, Size size) {
    final gridPaint = Paint()
      ..color = gridColor
      ..strokeWidth = 1 / controller.zoom;

    final startX = (-controller.canvasOffset.dx / controller.zoom / controller.gridSize).floor() * controller.gridSize;
    final endX =
        ((size.width - controller.canvasOffset.dx) / controller.zoom / controller.gridSize).ceil() * controller.gridSize;
    final startY = (-controller.canvasOffset.dy / controller.zoom / controller.gridSize).floor() * controller.gridSize;
    final endY =
        ((size.height - controller.canvasOffset.dy) / controller.zoom / controller.gridSize).ceil() * controller.gridSize;

    for (double x = startX; x <= endX; x += controller.gridSize) {
      canvas.drawLine(
        Offset(x, startY),
        Offset(x, endY),
        gridPaint,
      );
    }

    for (double y = startY; y <= endY; y += controller.gridSize) {
      canvas.drawLine(
        Offset(startX, y),
        Offset(endX, y),
        gridPaint,
      );
    }
  }

  @override
  bool shouldRepaint(InfiniteCanvasPainter oldDelegate) {
    return true;
  }
}


file: -- widgets\mini_map\mini_map.dart
import 'package:flutter/material.dart';
import '../canvas_controller.dart';
import 'mini_map_painter.dart';

class MiniMap extends StatelessWidget {
  final InfiniteCanvasController controller;
  final Size viewportSize;

  const MiniMap(
      {super.key, required this.controller, required this.viewportSize});

  @override
  Widget build(BuildContext context) {
    return Positioned(
      top: 20,
      left: 20,
      child: GestureDetector(
        onTapDown: (details) {
          final localPosition = details.localPosition;
          final canvasPosition = Offset(
            localPosition.dx / 0.4,
            localPosition.dy / 0.4,
          );
          controller.updateCanvasOffset(
            -canvasPosition.dx + viewportSize.width / (2 * controller.zoom),
            -canvasPosition.dy + viewportSize.height / (2 * controller.zoom),
          );
        },
        child: Container(
          width: 200,
          height: 200,
          decoration: BoxDecoration(
            border: Border.all(
                color: Theme.of(context).colorScheme.onTertiary, width: 2),
            color: Colors.white.withOpacity(0.2),
          ),
          child: CustomPaint(
            painter: MiniMapPainter(
              objects: controller.objects,
              canvasOffset: controller.canvasOffset,
              zoom: controller.zoom,
              viewportSize: viewportSize,
              gridSize: 10,
            ),
          ),
        ),
      ),
    );
  }
}


file: -- widgets\mini_map\mini_map_painter.dart
import 'package:flutter/material.dart';
import '../../models/canvas_object.dart';

/// Pintor personalizado para el minimapa.
class MiniMapPainter extends CustomPainter {
  final List<InfiniteCanvasObject> objects;
  final Offset canvasOffset;
  final double zoom;
  final Size viewportSize;
  final double gridSize;

  MiniMapPainter({
    required this.objects,
    required this.canvasOffset,
    required this.zoom,
    required this.viewportSize,
    required this.gridSize,
  });

  @override
  void paint(Canvas canvas, Size size) {
    final minimapScale = size.width / 1000;

    final backgroundPaint = Paint()..color = Colors.white.withOpacity(0.8);
    canvas.drawRect(
        Rect.fromLTWH(0, 0, size.width, size.height), backgroundPaint);

    // final gridPaint = Paint()
    //   ..color = Colors.grey.withOpacity(0.3)
    //   ..strokeWidth = 1;
    // for (double x = 0; x <= size.width; x += gridSize * minimapScale) {
    //   canvas.drawLine(Offset(x, 0), Offset(x, size.height), gridPaint);
    // }
    // for (double y = 0; y <= size.height; y += gridSize * minimapScale) {
    //   canvas.drawLine(Offset(0, y), Offset(size.width, y), gridPaint);
    // }

    for (var object in objects) {
      final position = Offset(
        object.position.dx * minimapScale,
        object.position.dy * minimapScale,
      );

      if (position.dx >= 0 &&
          position.dx <= size.width &&
          position.dy >= 0 &&
          position.dy <= size.height) {
        object.draw(canvas, Paint()..color = object.color, position, gridSize,
            minimapScale);
      }
    }

    final viewPortScale = minimapScale / 5;

    final viewportRect = Rect.fromLTWH(
      -canvasOffset.dx * viewPortScale,
      -canvasOffset.dy * viewPortScale,
      viewportSize.width * viewPortScale / zoom,
      viewportSize.height * viewPortScale / zoom,
    );

    final viewportPaint = Paint()
      ..color = Colors.blue.withOpacity(0.3)
      ..style = PaintingStyle.stroke
      ..strokeWidth = 1;
    canvas.drawRect(viewportRect, viewportPaint);
  }

  @override
  bool shouldRepaint(MiniMapPainter oldDelegate) {
    return true;
  }
}


file: -- widgets\tools\action_bar.dart
import 'package:flutter/material.dart';
import 'package:parkar/infinite_canvas/models/signage_object.dart';
import '../../models/grid_object.dart';
import '../canvas_controller.dart';
import '../../models/text_object.dart';
import '../../models/spot_object.dart';

class ActionBar extends StatelessWidget {
  final InfiniteCanvasController controller;

  const ActionBar({super.key, required this.controller});

  @override
  Widget build(BuildContext context) {
    final selectedObject = controller.selectedObjects.first;
    final zoom = controller.zoom;
    final canvasOffset = controller.canvasOffset;
    final gridSize = controller.gridSize;

    // Obtén el ancho y alto del objeto seleccionado
    final size = selectedObject is GridObject ? selectedObject.size : const Size(0, 0);

    // Calcula la posición del ActionBar teniendo en cuenta el zoom y el desplazamiento
    final position = Offset(
      (selectedObject.position.dx * zoom) + canvasOffset.dx,
      (selectedObject.position.dy * zoom) + canvasOffset.dy,
    );

    return Positioned(
      top: position.dy + (size.height * gridSize),  // Posiciona el ActionBar debajo del objeto + 5 píxeles
      left: position.dx - ((size.width * gridSize) / 2), // Centra el ActionBar respecto al objeto
      child: Container(
        padding: const EdgeInsets.all(6), // Reducir el padding en un 30%
        decoration: BoxDecoration(
          color: Colors.white,
          borderRadius: BorderRadius.circular(6), // Reducir el borderRadius en un 30%
          boxShadow: const [
            BoxShadow(
                color: Colors.black26, blurRadius: 5, offset: Offset(0, 3))
          ],
        ),
        child: Row(
          children: [
            IconButton(
              icon: const Icon(Icons.rotate_right),
              onPressed: () => controller.rotateSelectedObjects(15.0),
              tooltip: "Rotar 15º",
              iconSize: 20, // Reducir el tamaño del ícono en un 30%
              color: Colors.blue, // Color para la acción de rotar
            ),
            IconButton(
              icon: const Icon(Icons.rotate_left),
              onPressed: () => controller.rotateSelectedObjects(-15.0),
              tooltip: "Rotar -15º",
              iconSize: 20, // Reducir el tamaño del ícono en un 30%
              color: Colors.blue, // Color para la acción de rotar
            ),
            if (selectedObject is SignageObject)
              IconButton(
                icon: const Icon(Icons.swap_horiz),
                onPressed: controller.toggleSignageDirection,
                tooltip: "Cambiar direccion",
                iconSize: 20, // Reducir el tamaño del ícono en un 30%
                color: Colors.orange, // Color para la acción de cambiar dirección
              ),
            if (selectedObject is SpotObject)
              IconButton(
                icon: const Icon(Icons.swap_horiz),
                onPressed: controller.toggleSpotStatus,
                tooltip: "Ocupado/libre",
                iconSize: 20, // Reducir el tamaño del ícono en un 30%
                color: Colors.green, // Color para la acción de cambiar estado
              ),
            if (selectedObject is TextObject)
              IconButton(
                icon: const Icon(Icons.edit),
                onPressed: () {
                  // Implementar lógica para editar texto
                },
                tooltip: "Editar texto",
                iconSize: 20, // Reducir el tamaño del ícono en un 30%
                color: Colors.purple, // Color para la acción de editar texto
              ),
            IconButton(
              icon: const Icon(Icons.delete),
              onPressed: controller.deleteSelectedObjects,
              tooltip: "Eliminar",
              iconSize: 20, // Reducir el tamaño del ícono en un 30%
              color: Colors.red, // Color para la acción de eliminar
            ),
          ],
        ),
      ),
    );
  }
}

file: -- widgets\tools\floating_buttons.dart
import 'package:flutter/material.dart';
import '../canvas_controller.dart';

class FloatingButtons extends StatelessWidget {
  final InfiniteCanvasController controller;

  const FloatingButtons({
    super.key,
    required this.controller,
  });

  @override
  Widget build(BuildContext context) {
    return Positioned(
      bottom: 20,
      right: 20,
      child: Column(
        mainAxisAlignment: MainAxisAlignment.end,
        children: [
          FloatingActionButton(
            onPressed: () {
              // Muestra un menú emergente con las opciones
              showModalBottomSheet(
                context: context,
                builder: (context) {
                  return Column(
                    mainAxisSize: MainAxisSize.min,
                    children: [
                      ListTile(
                        leading: const Icon(Icons.center_focus_strong),
                        title: const Text('Centrar lienzo'),
                        onTap: () {
                          controller.centerCanvas();
                          Navigator.pop(context);
                        },
                      ),
                      ListTile(
                        leading: const Icon(Icons.zoom_out_map),
                        title: const Text('Zoom predeterminado'),
                        onTap: () {
                          controller.resetZoom();
                          Navigator.pop(context);
                        },
                      ),
                      ListTile(
                        leading: Icon(controller.showGrid ? Icons.check_box : Icons.check_box_outline_blank),
                        title: const Text('Mostrar cuadrícula'),
                        onTap: () {
                          controller.setShowGrid(!controller.showGrid);
                          Navigator.pop(context);
                        },
                      ),
                    ],
                  );
                },
              );
            },
            tooltip: "Opciones",
            child: const Icon(Icons.more_vert),
            mini: true, // Reduce el tamaño del botón
          ),
        ],
      ),
    );
  }
}

file: -- widgets\tools\grid_object_bar.dart
import 'package:flutter/material.dart';
import 'package:parkar/infinite_canvas/models/signage_object.dart';
import 'package:parkar/infinite_canvas/models/facility_object.dart';
import 'package:parkar/infinite_canvas/models/spot_object.dart';
import '../canvas_controller.dart';

class GridObjectBar extends StatefulWidget {
  final InfiniteCanvasController controller;
  final Axis orientation; // Orientación de la barra (horizontal o vertical)

  const GridObjectBar({
    super.key,
    required this.controller,
    this.orientation = Axis.vertical, // Por defecto es vertical
  });

  @override
  _GridObjectBarState createState() => _GridObjectBarState();
}

class _GridObjectBarState extends State<GridObjectBar>
    with SingleTickerProviderStateMixin {
  bool _isExpanded = true; // Estado para controlar si está expandido o contraído

  // Mapa de colores para cada tipo de objeto
  final Map<Type, Color> _objectColors = {
    SpotObject: Colors.blue, // Color para SpotObject
    SignageObject: Colors.green, // Color para SignageObject
    FacilityObject: Colors.orange, // Color para FacilityObject
  };

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context); // Obtener el tema actual (Material 3)
    final isHorizontal = widget.orientation == Axis.horizontal;

    return AnimatedSize(
      duration: const Duration(milliseconds: 300), // Duración de la animación
      curve: Curves.easeInOut, // Curva de animación suave
      alignment: isHorizontal ? Alignment.centerLeft : Alignment.topCenter,
      child: Container(
        padding: const EdgeInsets.all(4),
        decoration: BoxDecoration(
          color: theme.colorScheme.surface, // Usar color de superficie del tema
          borderRadius: BorderRadius.circular(12),
          boxShadow: [
            BoxShadow(
              color: theme.shadowColor, // Usar color de sombra del tema
              blurRadius: 5,
              offset: const Offset(0, 3),
            ),
          ],
        ),
        child: IntrinsicWidth(
          child: IntrinsicHeight(
            child: Flex(
              direction: widget.orientation, // Orientación de los botones
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                IconButton(
                  icon: Icon(
                    isHorizontal
                        ? _isExpanded
                            ? Icons.chevron_right
                            : Icons.chevron_left
                        : _isExpanded
                            ? Icons.expand_less
                            : Icons.expand_more,
                    color: theme.colorScheme.primary, // Color primario del tema
                  ),
                  onPressed: () {
                    setState(() {
                      _isExpanded = !_isExpanded; // Cambiar estado de expansión
                    });
                  },
                  tooltip: _isExpanded ? "Contraer" : "Expandir",
                ),
                if (_isExpanded) ...[
                  _buildIconButton(
                    icon: Icons.local_parking,
                    objectType: SpotObject,
                    tooltip: "Spot",
                    onPressed: () => widget.controller.addGridObjectNode(
                      SpotObject(
                        type: SpotObjectType.car,
                        category: SpotObjectCategory.standart,
                        label: 'A1',
                        vehiclePlate: 'ABC123',
                      ),
                    ),
                  ),
                  _buildIconButton(
                    icon: Icons.arrow_right,
                    objectType: SignageObject,
                    tooltip: "Via",
                    onPressed: () => widget.controller.addGridObjectNode(
                      SignageObject(
                        type: SignageObjectType.via,
                        direction: SignageObjectDirection.right,
                      ),
                    ),
                  ),
                  _buildIconButton(
                    icon: Icons.login,
                    objectType: SignageObject,
                    tooltip: "Entrada",
                    onPressed: () => widget.controller.addGridObjectNode(
                      SignageObject(
                        type: SignageObjectType.entrance,
                        direction: SignageObjectDirection.right,
                      ),
                    ),
                  ),
                  _buildIconButton(
                    icon: Icons.logout,
                    objectType: SignageObject,
                    tooltip: "Salida",
                    onPressed: () => widget.controller.addGridObjectNode(
                      SignageObject(
                        type: SignageObjectType.exit,
                        direction: SignageObjectDirection.right,
                      ),
                    ),
                  ),
                  _buildIconButton(
                    icon: Icons.work,
                    objectType: FacilityObject,
                    tooltip: "Oficina",
                    onPressed: () => widget.controller.addGridObjectNode(
                      FacilityObject(
                        type: FacilityObjectType.office,
                      ),
                    ),
                  ),
                ],
              ],
            ),
          ),
        ),
      ),
    );
  }

  // Método para construir botones con estilos personalizados
  Widget _buildIconButton({
    required IconData icon,
    required Type objectType,
    required String tooltip,
    required VoidCallback onPressed,
  }) {
    final color = _objectColors[objectType] ?? Colors.grey; // Color por defecto si no se encuentra

    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 4, horizontal: 8),
      child: Tooltip(
        message: tooltip,
        child: IconButton(
          icon: Icon(icon, color: color),
          onPressed: onPressed,
          style: IconButton.styleFrom(
            backgroundColor: color.withOpacity(0.2),
            shape: RoundedRectangleBorder(
              borderRadius: BorderRadius.circular(8),
            ),
          ),
        ),
      ),
    );
  }
}

file: -- widgets\tools\mode_bar.dart
// ignore_for_file: prefer_const_literals_to_create_immutables

import 'package:flutter/material.dart';
import '../canvas_controller.dart';

class Modebar extends StatelessWidget {
  final InfiniteCanvasController controller;

  const Modebar({super.key, required this.controller});

  @override
  Widget build(BuildContext context) {
    return Positioned(
      top: 10,
      right: 10,
      child: Container(
        padding: const EdgeInsets.all(8),
        decoration: BoxDecoration(
          color: Colors.white,
          borderRadius: BorderRadius.circular(8),
          boxShadow: [
            const BoxShadow(
                color: Colors.black26, blurRadius: 5, offset: Offset(0, 3))
          ],
        ),
        child: Column(
          children: [
            IconButton(
              icon: const Icon(Icons.directions_car),
              onPressed: () =>
                  controller.setCanvasMode(DrawingMode.gridObject),
              color:
                  controller.canvasMode == DrawingMode.gridObject
                      ? Colors.blue
                      : Colors.grey,
              tooltip: "Agregar vehículo",
            ),
            IconButton(
              icon: const Icon(Icons.text_fields),
              onPressed: () =>
                  controller.setCanvasMode(DrawingMode.text),
              color: controller.canvasMode == DrawingMode.text
                  ? Colors.blue
                  : Colors.grey,
              tooltip: "Agregar texto",
            ),
          ],
        ),
      ),
    );
  }
}


